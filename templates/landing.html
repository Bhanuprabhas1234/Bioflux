<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wildlife Ecosystem Simulation</title>
    <link rel="stylesheet" href="/static/style.css">
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/objects/Water.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/objects/Sky.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
</head>
<body class="landing-page">
    <div class="landing-container">
        <div class="landing-header">
            <h1>Wildlife Ecosystem Dynamics</h1>
            <p>Experience the delicate balance between predators and prey in an immersive 3D environment</p>
            <a href="/simulation" class="cta-button">Launch Simulation</a>
        </div>
        
        <div id="ecosystem3d" class="landing-visualization"></div>
        
        <div class="landing-features">
            <div class="feature-card">
                <div class="feature-icon">ðŸ¦Œ</div>
                <h3>Dynamic Populations</h3>
                <p>Watch prey and predator populations fluctuate in real-time based on ecological principles</p>
            </div>
            <div class="feature-card">
                <div class="feature-icon">ðŸŒ¿</div>
                <h3>Interactive Environment</h3>
                <p>Explore a rich 3D ecosystem with day/night cycles and weather effects</p>
            </div>
            <div class="feature-card">
                <div class="feature-icon">ðŸ“Š</div>
                <h3>Scientific Insights</h3>
                <p>Learn about Lotka-Volterra equations and population dynamics</p>
            </div>
        </div>
    </div>

    <script>
        // Initialize 3D scene with enhanced settings
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xa3d1ff, 0.002);
        
        const container = document.getElementById('ecosystem3d');
        const width = container.clientWidth;
        const height = 600;
        
        const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 2000);
        camera.position.set(0, 120, 300);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Add advanced lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(100, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);
        
        const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.5);
        scene.add(hemisphereLight);

        // Add sky and water
        const sky = new THREE.Sky();
        sky.scale.setScalar(10000);
        scene.add(sky);

        const sun = new THREE.Vector3();
        const skyUniforms = sky.material.uniforms;
        skyUniforms['turbidity'].value = 10;
        skyUniforms['rayleigh'].value = 2;
        skyUniforms['mieCoefficient'].value = 0.005;
        skyUniforms['mieDirectionalG'].value = 0.8;
        
        const parameters = {
            elevation: 2,
            azimuth: 180
        };
        
        const updateSun = () => {
            const phi = THREE.MathUtils.degToRad(90 - parameters.elevation);
            const theta = THREE.MathUtils.degToRad(parameters.azimuth);
            sun.setFromSphericalCoords(1, phi, theta);
            skyUniforms['sunPosition'].value.copy(sun);
            directionalLight.position.copy(sun);
        };
        updateSun();

        // Create realistic terrain
        const terrainGeometry = new THREE.PlaneGeometry(500, 500, 100, 100);
        
        // Add terrain height variation
        const vertices = terrainGeometry.attributes.position;
        for (let i = 0; i < vertices.count; i++) {
            const x = vertices.getX(i);
            const z = vertices.getZ(i);
            const distance = Math.sqrt(x * x + z * z);
            const height = 10 * Math.sin(distance * 0.05) + 
                          5 * Math.sin(x * 0.1) + 
                          5 * Math.sin(z * 0.1);
            vertices.setY(i, height);
        }
        terrainGeometry.computeVertexNormals();
        
        const terrainMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x3a5f0b,
            wireframe: false,
            flatShading: false,
            side: THREE.DoubleSide
        });
        
        const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        terrain.rotation.x = -Math.PI / 2;
        terrain.receiveShadow = true;
        scene.add(terrain);

        // Add water with reflections
        const waterGeometry = new THREE.PlaneGeometry(1000, 1000);
        const water = new THREE.Water(
            waterGeometry,
            {
                textureWidth: 512,
                textureHeight: 512,
                waterNormals: new THREE.TextureLoader().load('https://threejs.org/examples/textures/waternormals.jpg', function(texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                }),
                sunDirection: new THREE.Vector3(),
                sunColor: 0xffffff,
                waterColor: 0x1a7ebd,
                distortionScale: 3.7,
                fog: scene.fog !== undefined
            }
        );
        water.rotation.x = -Math.PI / 2;
        water.position.y = 0;
        scene.add(water);

        // Add foliage (grass, bushes)
        const grassGeometry = new THREE.BufferGeometry();
        const grassCount = 1000;
        const grassPositions = new Float32Array(grassCount * 3);
        const grassScales = new Float32Array(grassCount);
        
        for (let i = 0; i < grassCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 100 + Math.random() * 350;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            // Get terrain height at this position
            let y = 0;
            if (x >= -250 && x <= 250 && z >= -250 && z <= 250) {
                const gridX = Math.floor((x + 250) / 5);
                const gridZ = Math.floor((z + 250) / 5);
                const index = gridZ * 101 + gridX;
                y = vertices.getY(index) + 0.5;
            }
            
            grassPositions[i * 3] = x;
            grassPositions[i * 3 + 1] = y;
            grassPositions[i * 3 + 2] = z;
            grassScales[i] = 0.5 + Math.random() * 1.5;
        }
        
        grassGeometry.setAttribute('position', new THREE.BufferAttribute(grassPositions, 3));
        grassGeometry.setAttribute('scale', new THREE.BufferAttribute(grassScales, 1));
        
        const grassMaterial = new THREE.PointsMaterial({
            color: 0x4CAF50,
            size: 1,
            sizeAttenuation: true
        });
        
        const grass = new THREE.Points(grassGeometry, grassMaterial);
        scene.add(grass);

        // Load models with placeholder geometry while loading
        const loader = new THREE.GLTFLoader();
        const models = [];
        const animals = [];
        let deerModel, tigerModel;

        // Placeholder animals while models load
        function createPlaceholderAnimal(type, color) {
            const height = type === 'deer' ? 5 : 3;
            const bodyGeo = new THREE.CylinderGeometry(1, 1, height, 8);
            const headGeo = new THREE.SphereGeometry(1.2, 8, 8);
            headGeo.translate(0, height/2 + 1.2, 1.5);
            
            const mergedGeo = new THREE.BufferGeometry();
            mergedGeo.merge(bodyGeo);
            mergedGeo.merge(headGeo);
            
            const material = new THREE.MeshPhongMaterial({ 
                color: color,
                flatShading: true 
            });
            
            const animal = new THREE.Mesh(mergedGeo, material);
            animal.castShadow = true;
            animal.receiveShadow = true;
            animal.userData = { type: type, speed: 0, targetPosition: null };
            return animal;
        }

        // Create initial animals with placeholders
        for (let i = 0; i < 12; i++) {
            const deer = createPlaceholderAnimal('deer', 0x8B4513);
            deer.position.x = Math.random() * 300 - 150;
            deer.position.z = Math.random() * 300 - 150;
            deer.rotation.y = Math.random() * Math.PI * 2;
            scene.add(deer);
            animals.push(deer);
        }
        
        // Load actual models
        // Load deer model
        loader.load('https://threejs.org/examples/models/gltf/Deer/glTF/Deer.gltf', function(gltf) {
            deerModel = gltf.scene;
            deerModel.scale.set(0.5, 0.5, 0.5);
            deerModel.traverse(function(node) {
                if (node.isMesh) {
                    node.castShadow = true;
                }
            });
            
            // Replace placeholders with actual models
            animals.forEach(animal => {
                if (animal.userData.type === 'deer') {
                    const deerInstance = deerModel.clone();
                    deerInstance.position.copy(animal.position);
                    deerInstance.rotation.copy(animal.rotation);
                    deerInstance.scale.set(0.5, 0.5, 0.5);
                    scene.add(deerInstance);
                    scene.remove(animal);
                    const index = animals.indexOf(animal);
                    animals[index] = deerInstance;
                    deerInstance.userData = animal.userData;
                }
            });
        });

        // Load tiger model from local server
        (async function loadTigerModel() {
            try {
                const loader = new THREE.GLTFLoader();
                loader.setPath('/model/tiger/'); // Set base path for textures/bin files
                
                const gltf = await new Promise((resolve, reject) => {
                    loader.load('scene.gltf', resolve, undefined, reject);
                });
                
                tigerModel = gltf.scene;
                tigerModel.scale.set(0.5, 0.5, 0.5);
                tigerModel.traverse(function(node) {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                
                // Add 4 tigers to the scene
                for (let i = 0; i < 4; i++) {
                    const tigerInstance = tigerModel.clone();
                    const x = Math.random() * 300 - 150;
                    const z = Math.random() * 300 - 150;
                    let y = 0;
                    
                    // Get terrain height at this position
                    if (x >= -250 && x <= 250 && z >= -250 && z <= 250) {
                        const gridX = Math.floor((x + 250) / 5);
                        const gridZ = Math.floor((z + 250) / 5);
                        const index = gridZ * 101 + gridX;
                        y = vertices.getY(index);
                    }
                    
                    tigerInstance.position.set(x, y + 1.5, z);
                    tigerInstance.rotation.y = Math.random() * Math.PI * 2;
                    scene.add(tigerInstance);
                    animals.push({
                        model: tigerInstance,
                        speed: 0.8 + Math.random() * 0.7,
                        type: 'tiger',
                        targetPosition: null
                    });
                }
            } catch (error) {
                console.error('Failed to load tiger model:', error);
                // Fallback to placeholder tigers
                for (let i = 0; i < 4; i++) {
                    const tiger = createPlaceholderAnimal('tiger', 0xFF8C00);
                    tiger.position.x = Math.random() * 300 - 150;
                    tiger.position.z = Math.random() * 300 - 150;
                    tiger.rotation.y = Math.random() * Math.PI * 2;
                    scene.add(tiger);
                    animals.push({
                        model: tiger,
                        speed: 0.8 + Math.random() * 0.7,
                        type: 'tiger',
                        targetPosition: null
                    });
                }
            }
        })();

        // Add trees (unchanged from your original code)
        for (let i = 0; i < 50; i++) {
            const height = 5 + Math.random() * 10;
            const trunkGeo = new THREE.CylinderGeometry(0.5, 0.8, height, 8);
            const leavesGeo = new THREE.SphereGeometry(height * 0.6, 8, 8);
            leavesGeo.translate(0, height/2 + height * 0.4, 0);
            
            const mergedGeo = new THREE.BufferGeometry();
            mergedGeo.merge(trunkGeo);
            mergedGeo.merge(leavesGeo);
            
            const treeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x3a5f0b,
                flatShading: true 
            });
            const trunkMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x5a2d0c,
                flatShading: true 
            });
            
            const tree = new THREE.Mesh(mergedGeo, [trunkMaterial, treeMaterial]);
            
            const angle = Math.random() * Math.PI * 2;
            const radius = 50 + Math.random() * 200;
            tree.position.x = Math.cos(angle) * radius;
            tree.position.z = Math.sin(angle) * radius;
            
            // Get terrain height at this position
            if (tree.position.x >= -250 && tree.position.x <= 250 && 
                tree.position.z >= -250 && tree.position.z <= 250) {
                const gridX = Math.floor((tree.position.x + 250) / 5);
                const gridZ = Math.floor((tree.position.z + 250) / 5);
                const index = gridZ * 101 + gridX;
                tree.position.y = vertices.getY(index);
            }
            
            tree.castShadow = true;
            tree.receiveShadow = true;
            scene.add(tree);
            models.push(tree);
        }

        // Add controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 100;
        controls.maxDistance = 500;
        controls.maxPolarAngle = Math.PI * 0.9;

        // Animation variables
        let time = 0;
        const clock = new THREE.Clock();
        
        // Animal behavior parameters
        const setRandomTarget = (animal) => {
            const angle = Math.random() * Math.PI * 2;
            const distance = animal.type === 'deer' ? 20 + Math.random() * 30 : 30 + Math.random() * 50;
            
            animal.targetPosition = new THREE.Vector3(
                animal.model.position.x + Math.cos(angle) * distance,
                0,
                animal.model.position.z + Math.sin(angle) * distance
            );
            
            // Ensure target is within bounds
            animal.targetPosition.x = THREE.MathUtils.clamp(animal.targetPosition.x, -250, 250);
            animal.targetPosition.z = THREE.MathUtils.clamp(animal.targetPosition.z, -250, 250);
            
            // Get terrain height at target position
            if (animal.targetPosition.x >= -250 && animal.targetPosition.x <= 250 && 
                animal.targetPosition.z >= -250 && animal.targetPosition.z <= 250) {
                const gridX = Math.floor((animal.targetPosition.x + 250) / 5);
                const gridZ = Math.floor((animal.targetPosition.z + 250) / 5);
                const index = gridZ * 101 + gridX;
                animal.targetPosition.y = vertices.getY(index);
            }
            
            animal.speed = animal.type === 'deer' ? 
                0.5 + Math.random() * 0.5 : 
                0.8 + Math.random() * 0.7;
        };

        // Initialize targets for all animals
        animals.forEach(animal => {
            setRandomTarget(animal);
        });

        // Predator-prey interaction
        const updatePredatorBehavior = () => {
            animals.forEach(predator => {
                if (predator.type !== 'tiger') return;
                
                // Find nearest prey
                let nearestPrey = null;
                let minDistance = Infinity;
                
                animals.forEach(prey => {
                    if (prey.type !== 'deer') return;
                    
                    const distance = predator.model.position.distanceTo(prey.model.position);
                    if (distance < 50 && distance < minDistance) {
                        minDistance = distance;
                        nearestPrey = prey;
                    }
                });
                
                // Chase prey if nearby
                if (nearestPrey) {
                    predator.targetPosition = nearestPrey.model.position.clone();
                    predator.speed = 1.5;
                } else if (!predator.targetPosition || 
                          predator.model.position.distanceTo(predator.targetPosition) < 5) {
                    setRandomTarget(predator);
                }
            });
        };

        // Animation loop
        const animate = () => {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            time += delta;
            
            // Update water
            if (water.material.uniforms) {
                water.material.uniforms['time'].value += delta * 0.5;
            }
            
            // Update sun position for day/night cycle
            parameters.azimuth = (time * 5) % 360;
            updateSun();
            
            // Update animal movements
            updatePredatorBehavior();
            
            animals.forEach(animal => {
                if (animal.targetPosition) {
                    const direction = new THREE.Vector3().subVectors(
                        animal.targetPosition, 
                        animal.model.position
                    ).normalize();
                    
                    // Move toward target
                    animal.model.position.add(direction.multiplyScalar(animal.speed));
                    
                    // Rotate to face direction of movement
                    if (direction.length() > 0) {
                        animal.model.rotation.y = Math.atan2(direction.x, direction.z);
                    }
                    
                    // Get terrain height at current position
                    if (animal.model.position.x >= -250 && animal.model.position.x <= 250 && 
                        animal.model.position.z >= -250 && animal.model.position.z <= 250) {
                        const gridX = Math.floor((animal.model.position.x + 250) / 5);
                        const gridZ = Math.floor((animal.model.position.z + 250) / 5);
                        const index = gridZ * 101 + gridX;
                        animal.model.position.y = vertices.getY(index) + (animal.type === 'deer' ? 2 : 1.5);
                    }
                    
                    // Set new target if reached current target
                    if (animal.model.position.distanceTo(animal.targetPosition) < 5) {
                        setRandomTarget(animal);
                    }
                }
            });
            
            // Update controls
            controls.update();
            
            // Render scene
            renderer.render(scene, camera);
        };
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            const newWidth = container.clientWidth;
            const newHeight = 600;
            
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
        });

        // Add info button
        const infoButton = document.createElement('div');
        infoButton.innerHTML = 'â“˜';
        infoButton.style.position = 'absolute';
        infoButton.style.top = '20px';
        infoButton.style.right = '20px';
        infoButton.style.fontSize = '24px';
        infoButton.style.cursor = 'pointer';
        infoButton.style.zIndex = '100';
        infoButton.style.backgroundColor = 'rgba(255,255,255,0.7)';
        infoButton.style.width = '36px';
        infoButton.style.height = '36px';
        infoButton.style.borderRadius = '50%';
        infoButton.style.display = 'flex';
        infoButton.style.justifyContent = 'center';
        infoButton.style.alignItems = 'center';
        infoButton.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
        container.appendChild(infoButton);
        
        infoButton.addEventListener('click', () => {
            Swal.fire({
                title: 'Ecosystem Simulation',
                html: `
                    <p>This 3D visualization demonstrates predator-prey dynamics in a wildlife ecosystem.</p>
                    <p><b>Tigers (predators)</b> hunt <b>deer (prey)</b>, while deer wander the terrain searching for food.</p>
                    <p>Use your mouse to rotate the view and scroll to zoom.</p>
                `,
                icon: 'info',
                confirmButtonText: 'Got it!'
            });
        });
    </script>
</body>
</html>